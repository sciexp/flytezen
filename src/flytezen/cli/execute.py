import importlib
import os
import pathlib
import secrets
import sys
import tempfile
from textwrap import dedent
from typing import Any, Dict

import rich.syntax
import rich.tree
from dotenv import load_dotenv
from flytekit.configuration import Config as FlyteConfig
from flytekit.configuration import FastSerializationSettings, ImageConfig, SerializationSettings
from flytekit.remote import FlyteRemote
from hydra.conf import HelpConf, HydraConf, JobConf
from hydra_zen import ZenStore, make_custom_builds_fn, to_yaml, zen

from flytezen.cli.execution_utils import (
    check_required_env_vars,
    git_info_to_workflow_version,
    wait_for_workflow_completion,
)
from flytezen.logging import configure_logging

logger = configure_logging("execute")
builds = make_custom_builds_fn(populate_full_signature=True)


# @dataclass_json
# @dataclass
# class ExecutionConfigClass:
#     """
#     A dataclass representing configuration for a workflow execution.
#     """

#     name: str = "training_workflow"
#     package_path: str = "src"
#     import_path: str = "flytezen.workflows.lrwine"
#     config_class: str = "Hyperparameters"
#     project: str = "flytesnacks"
#     domain: str = "development"
#     mode: str = "dev"
#     image: str = "ghcr.io/sciexp/flytezen"
#     tag: str = "main"
#     wait: bool = True
#     version: str = f"flytezen-main-{secrets.token_urlsafe(4)}".lower()
#     hyperparameters: Dict[str, Any] = field(default_factory=lambda: {"hyperparameters": LogisticRegression()})


# from flytezen.workflows.lrwine import Hyperparameters
from flytezen.configuration import LogisticRegressionInterface


# def execute_workflow(workflow: WorkflowConfigClass) -> None:
def execute_workflow(
    name: str = "training_workflow",
    package_path: str = "src",
    import_path: str = "flytezen.workflows.lrwine",
    config_class: str = "Hyperparameters",
    project: str = "flytesnacks",
    domain: str = "development",
    mode: str = "dev",
    image: str = "ghcr.io/sciexp/flytezen",
    tag: str = "main",
    wait: bool = True,
    version: str = f"flytezen-main-{secrets.token_urlsafe(4)}".lower(),
    inputs: Dict[str, Any] = {"logistic_regression": builds(LogisticRegressionInterface)},
) -> None:
    """
    Executes the given workflow based on the Hydra configuration, supporting two modes
    of execution controlled by 'mode':

    - 'dev': Executes a copy of the local workflow on the remote for development purposes.
      This mode allows for testing changes to the workflow code remotely without needing
      to rebuild and push the container image. If there is a significant change in dependencies,
      rebuilding and pushing the image may be required (see `make -n build_images`). This mode
      uses the container image tagged with the current branch tag, which corresponds to the
      git short SHA tag pointing to the HEAD of the branch. The workflow version is appended
      with a random string generated by '-dev-{secrets.token_urlsafe(2)}'. This mode is
      intended for development purposes only and should not be used in production or CI
      environments. Refer to `make -n run_unregistered` for usage examples.

    - 'prod': Registers the workflow on the remote and then executes it, intended for
      production or CI environments. This mode executes the workflow against a container
      image that has been built and pushed to the registry specified in execution.image.
      The container image used in this mode is tagged with the git short SHA. This mode
      requires that the container image with code equivalent to the current local copy has
      been built, typically in CI environments just prior to executing the workflow.

    In both modes, the workflow is registered with Flyte and then executed. The function
    logs various informational messages, including the execution URL, and optionally waits
    for workflow completion based on the `wait` flag in the workflow configuration.

    Args:
        name (str): The name of the workflow function to execute.
        package_path (str): The path to the workflow package.
        import_path (str): The import path of the workflow function to execute.
        config_class (str): The name of the configuration class containing hyperparameters.
        project (str): The Flyte project in which to register or execute the workflow.
        domain (str): The Flyte domain in which to register or execute the workflow.
        mode (str): Mode of workflow registration - 'dev' for fast registration and
                    'prod' for manual registration.
        image (str): The container image FQN to use for executing the workflow.
        tag (str): The tag to append to the container image FQN to use for executing the workflow.
        wait (bool): Flag indicating whether to wait for the workflow execution to complete or run async.
        version (str): The version of the workflow, including a git commit hash or other identifier(s).
        inputs (Dict[str, Any]): The inputs to the workflow function to execute. Keys are strings of
        the names of the workflow function arguments and values are the specific input values
        overriding the defaults.

    Raises:
        Sets exit status one if 'mode' has an invalid value.
    """

    module = importlib.import_module(import_path)
    entity = getattr(module, name)
    remote = FlyteRemote(
        config=FlyteConfig.auto(),
        default_project=project,
        default_domain=domain,
    )
    image_config = ImageConfig.auto(img_name=f"{image}:{tag}")

    if mode == "dev":
        logger.warning(
            "This mode is intended for development purposes only.\n\n"
            "Please use 'prod' mode for production or CI environments.\n\n"
        )
        with tempfile.TemporaryDirectory() as tmp_dir:
            logger.debug(f"Packaged tarball temporary directory:\n\n\t{tmp_dir}\n")
            _, upload_url = remote.fast_package(
                pathlib.Path(package_path),
                output=tmp_dir,
            )
        logger.info(f"Workflow package uploaded to:\n\n  {upload_url}\n")

        serialization_settings = SerializationSettings(
            image_config=image_config,
            fast_serialization_settings=FastSerializationSettings(
                enabled=True,
                destination_dir="/root",
                distribution_location=upload_url,
            ),
        )
    elif mode == "prod":
        logger.info(f"Registering workflow:\n\n\t{import_path}\n")
        serialization_settings = SerializationSettings(image_config=image_config)
    else:
        logger.error(
            f"Invalid workflow registration mode: {mode}. "
            "Please set WORKFLOW_REGISTRATION_MODE to either 'dev'"
            "or 'prod' in your environment."
        )
        sys.exit(1)

    remote.register_workflow(
        entity=entity,
        serialization_settings=serialization_settings,
        version=version,
    )
    execution = remote.execute(
        entity=entity,
        # inputs={"hyperparameters": hyperparameters},
        inputs=inputs,
        version=version,
        execution_name_prefix=version,
        wait=False,
    )
    logger.info(f"Execution submitted:\n\n{execution}\n")
    logger.info(f"Execution url:\n\n{remote.generate_console_url(execution)}\n")

    if wait:
        wait_for_workflow_completion(execution, remote, logger)


def main() -> None:
    """
    Main function that executes the workflow on the remote in one of two modes determined
    by "WORKFLOW_REGISTRATION_MODE":

    - In 'dev' mode, it uses the container image with the current branch tag for execution.
      This allows executing a copy of updated local workflow on the remote
      prior to building a new image.
    - In 'prod' mode, it uses the container image with the git short SHA tag just after
      building an image. This is primarily for CI execution.

    Note this logic regarding the image tag is independent of setting domain to "development",
    "staging", "production", etc.

    The workflow version is also separately determined based on the current git repo name,
    branch, and commit SHA.
    """

    load_dotenv()

    check_required_env_vars(
        [
            "WORKFLOW_NAME",
            "WORKFLOW_PACKAGE_PATH",
            "WORKFLOW_IMPORT_PATH",
            "WORKFLOW_CONFIG_CLASS_NAME",
            "WORKFLOW_PROJECT",
            "WORKFLOW_DOMAIN",
            "WORKFLOW_REGISTRATION_MODE",
            "WORKFLOW_IMAGE",
        ],
        logger,
    ) or sys.exit(1)

    store = ZenStore(name="flytezen", deferred_hydra_store=False)

    hydra_conf = HydraConf(
        defaults=[
            {"output": "default"},
            {"launcher": "basic"},  # joblib
            {"sweeper": "basic"},
            {"help": "default"},
            {"hydra_help": "default"},
            {"hydra_logging": "none"},  # default
            {"job_logging": "none"},  # default
            {"callbacks": None},
            {"env": "default"},
        ],
        help=HelpConf(
            header=dedent(
                """
                ${hydra.help.app_name} is the CLI of a template designed to illustrate the integration of:

                  * hydra-zen (https://mit-ll-responsible-ai.github.io/hydra-zen/),
                  * hydra (https://hydra.cc/), and
                  * omegaconf (https://omegaconf.readthedocs.io/),

                which provide configuration management, with

                  * flyte(kit) (https://flyte.org/),

                which manages the registration and execution of Flyte workflows.
                ${hydra.help.app_name} can be adapted as an auxiliary component of any python package,
                enhancing its capabilities in managing complex workflow configuration
                and execution.

                Running `${hydra.help.app_name} -h` displays the current configuration of ${hydra.help.app_name}.
                This reflects what will be executed if `flytezen` is run without arguments.

                Use `${hydra.help.app_name} --cfg hydra` to view the associated hydra configuration.

                """
            ),
            footer="Use `${hydra.help.app_name} --hydra-help` to view the hydra help.",
            template=dedent(
                """
                ${hydra.help.header}
                == Config ==
                Override anything in the config (foo.bar=value)

                $CONFIG
                ${hydra.help.footer}
                """
            ),
        ),
        job=JobConf(name="flytezen"),
    )
    store(hydra_conf)

    repo_name, git_branch, git_short_sha = git_info_to_workflow_version(logger)
    workflow_import_path = os.environ.get("WORKFLOW_IMPORT_PATH")
    module = importlib.import_module(workflow_import_path)
    workflow = getattr(module, os.environ.get("WORKFLOW_NAME"))
    # WorkflowConf = builds(workflow)

    workflow_config_class_name = os.environ.get("WORKFLOW_CONFIG_CLASS_NAME")
    # config_class = getattr(module, workflow_config_class_name)

    workflow_registration_mode = os.environ.get("WORKFLOW_REGISTRATION_MODE")
    if workflow_registration_mode == "dev":
        image_tag = git_branch
        dev_random = "".join(secrets.choice("abcdefghijklmnopqrstuvwxyz0123456789") for _ in range(3))
        workflow_version = f"{repo_name}-{git_branch}-{git_short_sha}-dev-{dev_random}"
    elif workflow_registration_mode == "prod":
        image_tag = git_short_sha
        workflow_version = f"{repo_name}-{git_branch}-{git_short_sha}"
    else:
        logger.error(
            f"Invalid workflow registration mode: {workflow_registration_mode}.\n"
            "Please set WORKFLOW_REGISTRATION_MODE to either 'dev' or 'prod' in your environment."
        )
        sys.exit(1)

    # workflow_config = ExecutionConfigClass(
    #     name=os.environ.get("WORKFLOW_NAME"),
    #     package_path=os.environ.get("WORKFLOW_PACKAGE_PATH"),
    #     import_path=workflow_import_path,
    #     config_class=workflow_config_class_name,
    #     project=os.environ.get("WORKFLOW_PROJECT"),
    #     domain=os.environ.get("WORKFLOW_DOMAIN"),
    #     mode=workflow_registration_mode,
    #     version=workflow_version.lower(),
    #     image=os.environ.get("WORKFLOW_IMAGE"),
    #     tag=image_tag,
    #     wait=True,
    #     hyperparameters=config_class(),
    # )

    ExecutionConf = builds(
        execute_workflow,
        # name=os.environ.get("WORKFLOW_NAME"),
        # package_path=os.environ.get("WORKFLOW_PACKAGE_PATH"),
        # import_path=workflow_import_path,
        # config_class=workflow_config_class_name,
        # project=os.environ.get("WORKFLOW_PROJECT"),
        # domain=os.environ.get("WORKFLOW_DOMAIN"),
        mode=workflow_registration_mode,
        version=workflow_version.lower(),
        image=os.environ.get("WORKFLOW_IMAGE"),
        tag=image_tag,
        # wait=True,
        # hyperparameters=config_class(),
    )
    # store(
    #     execute_workflow,
    #     workflow=workflow_config,
    # )
    store(
        ExecutionConf,
        name="execute_workflow",
    )

    store.add_to_hydra_store()

    config_yaml = to_yaml(ExecutionConf)
    tree = rich.tree.Tree("workflow", style="dim", guide_style="dim")
    tree.add(rich.syntax.Syntax(config_yaml, "yaml", theme="monokai"))
    rich.print(tree)

    zen(execute_workflow).hydra_main(
        config_name="execute_workflow",
        version_base="1.3",
        config_path=None,
    )


if __name__ == "__main__":
    """
    This script executes a Flyte workflow configured with hydra-zen.
    > flytezen --help

    == Config ==
    Override anything in the config (foo.bar=value)

    _target_: flytezen.cli.execute.execute_workflow
    execution:
      _target_: flytezen.cli.execute.ExecutionConfigClass
      name: training_workflow
      package_path: src
      import_path: flytezen.workflows.lrwine
      config_class: Hyperparameters
      project: flytesnacks
      domain: development
      mode: dev
      image: ghcr.io/org/flytezen
      tag: main
      wait: true
      version: flytezen-main-16323b3
      inputs:
        hyperparameters:
          _target_: sklearn.linear_model._logistic.LogisticRegression
          penalty: l2
          dual: false
          tol: 0.0001
          C: 1.0
          fit_intercept: true
          intercept_scaling: 1
          class_weight: null
          random_state: null
          solver: lbfgs
          max_iter: 100
          multi_class: auto
          verbose: 0
          warm_start: false
          n_jobs: null
          l1_ratio: null

    Example usage:
        > flytezen -h
        > flytezen \
            execution.hyperparameters.C=0.4 \
            execution.hyperparameters.max_iter=1200
        > flytezen \
            --multirun execution.hyperparameters.C=0.2,0.5

        See the the hydra config output in the git-ignored `./outputs` or
        `./multirun` directories. These are also stored as an artifact of
        the CI actions workflow in the `Upload config artifact` step.

    Warning:
        Hydra command-line overrides are only supported for hyperparameters.
        Do not override workflow-level parameters. This will lead to unexpected behavior.
        You can modify workflow parameters with `.env` or environment variables.
        Note  `execution.version` and `execution.tag` are determined
        automatically in python based on `execution.mode`. The workflow parameters are
        stored in the hydra config output for reference.
    """
    main()
