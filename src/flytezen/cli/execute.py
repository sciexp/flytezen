import importlib
import inspect
import os
import pathlib
import sys
import tempfile
from typing import Any, Dict

import rich.syntax
import rich.tree
from dotenv import load_dotenv
from flytekit.configuration import Config as FlyteConfig
from flytekit.configuration import (
    FastSerializationSettings,
    ImageConfig,
    SerializationSettings,
)
from flytekit.remote import FlyteRemote
from hydra_zen import ZenStore, make_custom_builds_fn, to_yaml, zen
from omegaconf import DictConfig

from flytezen.cli.execution_utils import (
    check_required_env_vars,
    generate_hydra_config,
    git_info_to_workflow_version,
    random_alphanumeric_suffix,
    wait_for_workflow_completion,
)
from flytezen.logging import configure_logging

logger = configure_logging("execute")
builds = make_custom_builds_fn(populate_full_signature=True)


def execute_workflow(
    zen_cfg: DictConfig,
    name: str = "training_workflow",
    package_path: str = "src",
    import_path: str = "flytezen.workflows.lrwine",
    project: str = "flytesnacks",
    domain: str = "development",
    mode: str = "dev",
    image: str = "ghcr.io/sciexp/flytezen",
    tag: str = "main",
    wait: bool = True,
    version: str = f"flytezen-main-{random_alphanumeric_suffix()}",
    inputs: Dict[str, Any] = {},
) -> None:
    """
    Executes the given workflow based on the Hydra configuration, supporting two modes
    of execution controlled by 'mode':

    - 'local': Attempts to execute the workflow locally without registering it on the remote.

    - 'dev': Executes a copy of the local workflow on the remote for development purposes.
      This mode allows for testing changes to the workflow code remotely without needing
      to rebuild and push the container image. If there is a significant change in dependencies,
      rebuilding and pushing the image may be required (see `make -n build_images`). This mode
      uses the container image tagged with the current branch tag, which corresponds to the
      git short SHA tag pointing to the HEAD of the branch. The workflow version is appended
      with a random string generated by '-dev-{secrets.token_urlsafe(2)}'. This mode is
      intended for development purposes only and should not be used in production or CI
      environments. Refer to `make -n run_unregistered` for usage examples.

    - 'prod': Registers the workflow on the remote and then executes it, intended for
      production or CI environments. This mode executes the workflow against a container
      image that has been built and pushed to the registry specified in execution.image.
      The container image used in this mode is tagged with the git short SHA. This mode
      requires that the container image with code equivalent to the current local copy has
      been built, typically in CI environments just prior to executing the workflow.

    In both modes, the workflow is registered with Flyte and then executed. The function
    logs various informational messages, including the execution URL, and optionally waits
    for workflow completion based on the `wait` flag in the workflow configuration.



    Args:
        name (str): The name of the workflow function to execute.
        package_path (str): The path to the workflow package.
        import_path (str): The import path of the workflow function to execute.
        project (str): The Flyte project in which to register or execute the workflow.
        domain (str): The Flyte domain in which to register or execute the workflow.
        mode (str): Mode of workflow registration - 'dev' for fast registration and
                    'prod' for manual registration.
        image (str): The container image FQN to use for executing the workflow.
        tag (str): The tag to append to the container image FQN to use for executing the workflow.
        wait (bool): Flag indicating whether to wait for the workflow execution to complete or run async.
        version (str): The version of the workflow, including a git commit hash or other identifier(s).
        inputs (Dict[str, Any]): The inputs to the workflow function to execute. Keys are strings of
        the names of the workflow function arguments and values are the specific input values
        overriding the defaults.

        TODO: Dynamic configuration of `inputs` argument should be required, but it is placed
        at the bottom due to the length in printing the config.
        The parameters should be reorderd in hydra/to_yaml and this can then be moved
        to the top of the arg list and made required.

    Raises:
        Sets exit status one if 'mode' has an invalid value.
    """
    config_yaml = to_yaml(zen_cfg)
    tree = rich.tree.Tree("workflow", style="dim", guide_style="dim")
    tree.add(rich.syntax.Syntax(config_yaml, "yaml", theme="monokai"))
    rich.print(tree)

    module = importlib.import_module(import_path)
    entity = getattr(module, name)

    # https://github.com/flyteorg/flytekit/blob/dc9d26bfd29d7a3482d1d56d66a806e8fbcba036/flytekit/clis/sdk_in_container/run.py#L477
    if mode == "local":
        output = entity(**inputs)
        logger.info(f"Workflow output:\n\n{output}\n")
        return

    remote = FlyteRemote(
        config=FlyteConfig.auto(),
        default_project=project,
        default_domain=domain,
    )
    image_config = ImageConfig.auto(img_name=f"{image}:{tag}")

    if mode == "dev":
        logger.warning(
            "This mode is intended for development purposes only.\n\n"
            "Please use 'prod' mode for production or CI environments.\n\n"
        )
        with tempfile.TemporaryDirectory() as tmp_dir:
            logger.debug(
                f"Packaged tarball temporary directory:\n\n\t{tmp_dir}\n"
            )
            _, upload_url = remote.fast_package(
                pathlib.Path(package_path),
                output=tmp_dir,
            )
        logger.info(f"Workflow package uploaded to:\n\n  {upload_url}\n")

        serialization_settings = SerializationSettings(
            image_config=image_config,
            fast_serialization_settings=FastSerializationSettings(
                enabled=True,
                destination_dir="/root",
                distribution_location=upload_url,
            ),
        )
    elif mode == "prod":
        logger.info(f"Registering workflow:\n\n\t{import_path}\n")
        serialization_settings = SerializationSettings(
            image_config=image_config
        )
    else:
        logger.error(
            f"Invalid workflow registration mode: {mode}. "
            "Please set WORKFLOW_REGISTRATION_MODE to either 'dev'"
            "or 'prod' in your environment."
        )
        sys.exit(1)

    remote.register_workflow(
        entity=entity,
        serialization_settings=serialization_settings,
        version=version,
    )
    execution = remote.execute(
        entity=entity,
        inputs=inputs,
        version=version,
        execution_name_prefix=version,
        wait=False,
    )
    logger.info(f"Execution submitted:\n\n{execution}\n")
    logger.info(f"Execution url:\n\n{remote.generate_console_url(execution)}\n")

    if wait:
        wait_for_workflow_completion(execution, remote, logger)


def generate_workflow_inputs(
    workflow_import_path: str = "flytezen.workflows.lrwine",
    workflow_name: str = "training_workflow",
) -> Dict[str, Any]:
    module = importlib.import_module(workflow_import_path)
    workflow = getattr(module, workflow_name)

    if not callable(workflow):
        value_error_message = f"Workflow '{workflow_name}' is not callable"
        raise ValueError(value_error_message)

    inputs = {}

    for name, param in inspect.signature(workflow).parameters.items():
        param_type = param.annotation
        default = param.default

        # Check if the type is a built-in type (like int, str, etc.)
        if isinstance(param_type, type) and param_type.__module__ == "builtins":
            inputs[name] = default
        else:
            # Dynamically import the type if it's not a built-in type
            type_module = importlib.import_module(param_type.__module__)
            custom_type = getattr(type_module, param_type.__name__)

            # CustomTypeConf = builds(custom_type)
            # inputs[name] = CustomTypeConf()
            inputs[name] = builds(custom_type)

    return inputs


def main() -> None:
    """
    Main function that executes the workflow on the remote in one of two modes determined
    by "WORKFLOW_REGISTRATION_MODE":

    - In 'dev' mode, it uses the container image with the current branch tag for execution.
      This allows executing a copy of updated local workflow on the remote
      prior to building a new image.
    - In 'prod' mode, it uses the container image with the git short SHA tag just after
      building an image. This is primarily for CI execution.

    Note this logic regarding the image tag is independent of setting domain to "development",
    "staging", "production", etc.

    The workflow version is also separately determined based on the current git repo name,
    branch, and commit SHA.
    """

    load_dotenv()

    check_required_env_vars(
        [
            "WORKFLOW_NAME",
            "WORKFLOW_PACKAGE_PATH",
            "WORKFLOW_IMPORT_PATH",
            "WORKFLOW_PROJECT",
            "WORKFLOW_DOMAIN",
            "WORKFLOW_REGISTRATION_MODE",
            "WORKFLOW_IMAGE",
        ],
        logger,
    ) or sys.exit(1)

    store = ZenStore(name="flytezen", deferred_hydra_store=False)

    store(generate_hydra_config())

    repo_name, git_branch, git_short_sha = git_info_to_workflow_version(logger)

    workflow_registration_mode = os.environ.get("WORKFLOW_REGISTRATION_MODE")
    if workflow_registration_mode == "dev":
        image_tag = git_branch
        workflow_version = f"{repo_name}-{git_branch}-{git_short_sha}-dev-{random_alphanumeric_suffix()}"
    elif workflow_registration_mode == "prod":
        image_tag = git_short_sha
        workflow_version = f"{repo_name}-{git_branch}-{git_short_sha}"
    else:
        logger.error(
            f"Invalid workflow registration mode: {workflow_registration_mode}.\n"
            "Please set WORKFLOW_REGISTRATION_MODE to either 'dev' or 'prod' in your environment."
        )
        sys.exit(1)

    workflow_import_path = os.environ.get("WORKFLOW_IMPORT_PATH")
    workflow_name = os.environ.get("WORKFLOW_NAME")

    # TODO: Build workflow inputs dynamically from workflow import path to allow
    #       overrides from the hydra CLI.
    #
    # WorkflowConf = builds(generate_workflow_inputs)
    #
    # The separate dependency on the workflow import path and name
    # here and in ExecutionConf prevents hydra CLI override of the workflow
    workflow_inputs = generate_workflow_inputs(
        workflow_import_path=workflow_import_path,
        workflow_name=workflow_name,
    )

    # For parameters marked as `NOT overridable`,
    # the value is determined by the env var
    # and cannot be overriden by the hydra CLI.
    # You can combine env vars and hydra CLI overrides
    # > WORKFLOW_NAME=wf \
    # > WORKFLOW_IMPORT_PATH=flytezen.workflows.example \
    # > flytezen \
    # > wait=false \
    # > inputs.name=flyte
    ExecutionConf = builds(
        execute_workflow,
        name=workflow_name,  # NOT overridable, determines inputs
        import_path=workflow_import_path,  # NOT overridable, determines inputs
        mode=workflow_registration_mode,  # NOT overridable, determines image tag
        version=workflow_version.lower(),  # NOT overridable, depends on git branch and commit sha
        image=os.environ.get(
            "WORKFLOW_IMAGE"
        ),  # Overridable, may be private information
        tag=image_tag,  # NOT overridable, depends on git branch or commit sha
        inputs=workflow_inputs,  # Overridable subcomponents, see `flytezen -h`
        # package_path=os.environ.get("WORKFLOW_PACKAGE_PATH"), # Overridable
        # project=os.environ.get("WORKFLOW_PROJECT"), # Overridable
        # domain=os.environ.get("WORKFLOW_DOMAIN"), # Overridable
        # wait=True, # Overridable
    )

    store(
        ExecutionConf,
        name="execute_workflow",
    )

    store.add_to_hydra_store()

    zen(execute_workflow).hydra_main(
        config_name="execute_workflow",
        version_base="1.3",
        config_path=None,
    )


if __name__ == "__main__":
    """
    This script executes a Flyte workflow configured with hydra-zen.
    > flytezen --help

    == Config ==
    Override anything in the config (foo.bar=value)

    _target_: flytezen.cli.execute.execute_workflow
    zen_cfg: ???
    name: training_workflow
    package_path: src
    import_path: flytezen.workflows.lrwine
    project: flytesnacks
    domain: development
    mode: dev
    image: ghcr.io/org/flytezen
    tag: main
    wait: true
    version: flytezen-main-16323b3-dev-a8x
    inputs:
      logistic_regression:
        _target_: sklearn.linear_model._logistic.LogisticRegression
        penalty: l2
        dual: false
        tol: 0.0001
        C: 1.0
        fit_intercept: true
        intercept_scaling: 1
        class_weight: null
        random_state: null
        solver: lbfgs
        max_iter: 100
        multi_class: auto
        verbose: 0
        warm_start: false
        n_jobs: null
        l1_ratio: null

    Example usage:
        > flytezen -h
        > flytezen \
            inputs.logistic_regression.C=0.4 \
            inputs.logistic_regression.max_iter=1200
        > flytezen \
            --multirun inputs.logistic_regression.C=0.2,0.5

        See the the hydra config output in the git-ignored `./outputs` or
        `./multirun` directories. These are also stored as an artifact of
        the CI actions workflow in the `Upload config artifact` step.

    Warning:
        Hydra command-line overrides are only intended to be supported for inputs.
        Do not override workflow-level parameters. This will lead to unexpected behavior.
        You can modify workflow parameters with `.env` or environment variables.
        Note  `version` and `tag` are determined automatically in python based on `mode`.
        The workflow execution parameters are stored in the hydra config output for reference.
    """
    main()
